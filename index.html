<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Vykha's Birthday Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        body { font-family: 'Press Start 2P', cursive; background: #87ceeb; overflow: hidden; touch-action: none; }
        #gameContainer { 
            width: 100vw; 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start;   /* push content to top */
            padding-top: 80px;             /* space for HUD */
            padding-bottom: 160px;         /* reserve space for D-pad */
        }

        #gameCanvas {
            border:4px solid #2d3748;
            background:#87ceeb;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: min(100vw, 360px);   /* mobile friendly scaling */
            height: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            margin-top: 20px;
        }
        #controls { position: fixed; bottom: 20px; left:50%; transform: translateX(-50%); display:grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px; gap:2px; z-index:1000; }
        .btn { background: linear-gradient(145deg,#4a5568,#2d3748); border:3px solid #1a202c; display:flex; align-items:center; justify-content:center; color:#fff; font-size:24px; font-weight:bold; cursor:pointer; touch-action:none; box-shadow:0 4px 0 #1a202c, inset 0 -2px 8px rgba(0,0,0,0.3); transition: all .1s; }
        .btn:active { transform: translateY(2px); box-shadow:0 2px 0 #1a202c, inset 0 -2px 8px rgba(0,0,0,0.3); }
        #upBtn { grid-column: 2; grid-row:1; border-radius: 8px 8px 0 0; }
        #leftBtn { grid-column:1; grid-row:2; border-radius: 8px 0 0 8px; }
        #rightBtn { grid-column:3; grid-row:2; border-radius: 0 8px 8px 0; }
        #downBtn { grid-column:2; grid-row:2; background: linear-gradient(145deg,#2d3748,#1a202c); pointer-events:none; opacity:0.5; }
        #hud { position:fixed; top:20px; left:50%; transform:translateX(-50%); color:#fff; font-size:10px; background: rgba(45,55,72,0.9); padding:10px 20px; border:3px solid #2d3748; z-index:1000; text-align:center; min-width:200px; box-shadow:0 4px 16px rgba(0,0,0,0.3); border-radius:8px; }
        #notification { position: fixed; top:110px; left:50%; transform: translateX(-50%) translateY(-150px); color:#fff; font-size:10px; background: rgba(45,55,72,0.95); padding:12px 16px; border:3px solid #fbbf24; z-index:1000; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,0.3); display:flex; align-items:center; gap:12px; opacity:0; transition: all .3s ease-out; }
        #notification.show { transform: translateX(-50%) translateY(0); opacity:1; }
        #notification .cake-icon { font-size:24px; }
        #endScreen { position:fixed; top:0; left:0; width:100vw; height:100vh; background:#87ceeb; display:none; flex-direction:column; align-items:center; justify-content:center; z-index:2000; color:#2d3748; text-align:center; padding:20px; }
        #endScreen h1 { font-size:24px; margin-bottom:20px; animation: pulse 2s infinite; text-shadow:0 2px 8px rgba(0,0,0,0.1); }
        #endScreen p { font-size:16px; margin-top:10px; text-shadow:0 2px 8px rgba(0,0,0,0.1); }
        @keyframes pulse { 0%,100%{transform:scale(1);} 50%{transform:scale(1.1);} }
        .heart { font-size:64px; animation: heartbeat 1s ease-in-out; }
        @keyframes heartbeat { 0%{transform:scale(0);opacity:0;} 50%{transform:scale(1.3);opacity:1;} 100%{transform:scale(1);opacity:1;} }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div>Level: <span id="levelDisplay">1</span> &nbsp; | &nbsp; Cakes: <span id="cakeCount">0</span></div>
        </div>

        <div id="notification">
            <div class="cake-icon">üç∞</div>
            <div id="notificationText"></div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="controls">
            <div class="btn" id="upBtn">‚ñ≤</div>
            <div class="btn" id="leftBtn">‚óÑ</div>
            <div class="btn" id="downBtn"></div>
            <div class="btn" id="rightBtn">‚ñ∫</div>
        </div>

        <div id="endScreen">
            <div class="heart">‚ù§Ô∏è</div>
            <h1>Happy Birthday Vykha</h1>
            <p>I love you, from dylan :)</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size for mobile (vertical orientation)
        const GAME_WIDTH = 320;
        const GAME_HEIGHT = 480;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // Game state (added level and totalCakesNeeded)
        let gameState = {
            level: 1,
            cakesCollected: 0,
            totalCakesNeeded: 0,
            achievements: [],
            gameEnded: false,
            finalGameComplete: false
        };

        // Load images
        const images = {};
        const imageSources = {
            ground: 'ground.png',
            platform: 'platform.png',
            sky: 'sky.png',
            sky2: 'sky2.png',
            sprite: 'sprite.png',
            sprite2: 'sprite2.png',
            sprite3: 'sprite3.png'
        };

        let imagesLoaded = 0;
        const totalImages = Object.keys(imageSources).length;

        for (let key in imageSources) {
            images[key] = new Image();
            images[key].onload = () => {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    startGame();
                }
            };
            images[key].src = imageSources[key];
            // Optional debug: images[key].onerror = () => console.log(key + ' failed to load');
        }

        // Player
        const player = {
            x: 50,
            y: GAME_HEIGHT - 100,
            width: 32,
            height: 48,
            velocityX: 0,
            velocityY: 0,
            speed: 2.5,
            jumpPower: 8,
            gravity: 0.35,
            onGround: false,
            facing: 1,
            isJumping: false
        };

        // Controls
        const keys = { left: false, right: false, up: false };

        // Touch controls
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => { e.preventDefault(); keys.left = true; });
        document.getElementById('leftBtn').addEventListener('touchend',   (e) => { e.preventDefault(); keys.left = false; });

        document.getElementById('rightBtn').addEventListener('touchstart',(e) => { e.preventDefault(); keys.right = true; });
        document.getElementById('rightBtn').addEventListener('touchend',  (e) => { e.preventDefault(); keys.right = false; });

        document.getElementById('upBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (player.onGround) {
                keys.up = true;
                player.velocityY = -player.jumpPower;
                player.onGround = false;
                player.isJumping = true;
            }
        });
        document.getElementById('upBtn').addEventListener('touchend', (e) => { e.preventDefault(); keys.up = false; });

        // Keyboard controls for desktop testing
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === 'ArrowUp' && player.onGround) {
                player.velocityY = -player.jumpPower;
                player.onGround = false;
                player.isJumping = true;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
        });

        // ----- ORIGINAL PLATFORMS & CAKES (kept exactly, but made mutable with let) -----
        let platforms = [
            // Ground platform at bottom
            { x: 0, y: GAME_HEIGHT - 40, width: GAME_WIDTH, height: 40, isGround: true },

            // Level 1 - First jump from ground
            { x: 130, y: GAME_HEIGHT - 110, width: 70, height: 15 },

            // Level 2
            { x: 40, y: GAME_HEIGHT - 180, width: 70, height: 15 },

            // Level 3
            { x: 210, y: GAME_HEIGHT - 250, width: 70, height: 15 },

            // Level 6
            { x: 50, y: 180, width: 70, height: 15 },

            // Level 7
            { x: 200, y: 110, width: 70, height: 15 },

            // Level 8 - Final platform for sprite3
            { x: 125, y: 50, width: 80, height: 15 }
        ];

        // Cake fragments (collectibles) - original 5
        let cakes = [
            { x: 155, y: GAME_HEIGHT - 145, width: 16, height: 16, collected: false, achievement: 0 },
            { x: 65, y: GAME_HEIGHT - 215, width: 16, height: 16, collected: false, achievement: 1 },
            { x: 235, y: GAME_HEIGHT - 285, width: 16, height: 16, collected: false, achievement: 2 },
            { x: 225, y: GAME_HEIGHT - 394, width: 16, height: 16, collected: false, achievement: 3 },
            { x: 75, y: 145, width: 16, height: 16, collected: false, achievement: 4 }
        ];

        // Keep copies of original layout so we can reset for each level
        const basePlatforms = JSON.parse(JSON.stringify(platforms));
        const baseCakes = JSON.parse(JSON.stringify(cakes));

        // Add extra achievementTexts to cover additional cakes (at least 7)
        const achievementTexts = [
            "üéÇ MY BABY",
            "üéÇ MY SWEETHEART",
            "üéÇ MY BEAUTIFUL",
            "üéÇ MY BAE",
            "üéÇ MY CHAKKARE KUTTY",
            "üéÇ MY SUNDARI PENNE",
            "üéÇ MY QUEEN"
        ];

        // End goal sprite3 at the top
        const goalSprite = { x: 145, y: 5, width: 32, height: 48 };

        // Background scroll and camera
        let skyScroll = 0;
        let heartVisible = false;
        let heartScale = 0;
        let cameraOffsetY = 0;
        let targetCameraOffsetY = 0;

        function showNotification(text) {
            const notification = document.getElementById('notification');
            const notificationText = document.getElementById('notificationText');

            notificationText.textContent = text;
            notification.classList.add('show');

            setTimeout(() => { notification.classList.remove('show'); }, 2000);
        }

        // ---------------- Level Loader ----------------
        function loadLevel(level) {

            gameState.level = level;
            document.getElementById('levelDisplay').textContent = level;

            gameState.cakesCollected = 0;
            heartVisible = false;
            heartScale = 0;
            cameraOffsetY = 0;
            targetCameraOffsetY = 0;
            gameState.gameEnded = false;

            player.x = 50;
            player.y = GAME_HEIGHT - 100;
            player.velocityY = 0;

            // ---------- LEVEL 1 (Original) ----------
            if (level === 1) {

                platforms = JSON.parse(JSON.stringify(basePlatforms));
                cakes = JSON.parse(JSON.stringify(baseCakes));
            }

            // ---------- LEVEL 2 (More Vertical + Wider Jumps) ----------
            if (level === 2) {

                platforms = [
                    { x: 0, y: GAME_HEIGHT - 40, width: GAME_WIDTH, height: 40, isGround: true },

                    { x: 40,  y: 380, width: 80, height: 15 },
                    { x: 210, y: 330, width: 70, height: 15 },
                    { x: 60,  y: 280, width: 70, height: 15 },
                    { x: 200, y: 230, width: 70, height: 15 },
                    { x: 90,  y: 180, width: 70, height: 15 },
                    { x: 180, y: 130, width: 80, height: 15 },
                    { x: 125, y: 50, width: 80, height: 15 }
                ];

                cakes = [
                    { x: 70,  y: 350, width: 16, height: 16, collected: false, achievement: 0 },
                    { x: 230, y: 300, width: 16, height: 16, collected: false, achievement: 1 },
                    { x: 80,  y: 250, width: 16, height: 16, collected: false, achievement: 2 },
                    { x: 220, y: 200, width: 16, height: 16, collected: false, achievement: 3 },
                    { x: 110, y: 150, width: 16, height: 16, collected: false, achievement: 4 },
                    { x: 210, y: 100, width: 16, height: 16, collected: false, achievement: 5 }
                ];
            }

            // ---------- LEVEL 3 (Harder / Tighter Platforms) ----------
            if (level === 3) {

                platforms = [
                    { x: 0, y: GAME_HEIGHT - 40, width: GAME_WIDTH, height: 40, isGround: true },

                    { x: 40,  y: 380, width: 70, height: 12,
                    moving: true, speed: 1.5, direction: 1, minX: 20, maxX: 200 },

                    { x: 200, y: 330, width: 70, height: 12,
                    moving: true, speed: 1.8, direction: -1, minX: 120, maxX: 280 },

                    { x: 60,  y: 280, width: 60, height: 12,
                    moving: true, speed: 2, direction: 1, minX: 30, maxX: 220 },

                    { x: 210, y: 230, width: 60, height: 12,
                    moving: true, speed: 2.2, direction: -1, minX: 140, maxX: 280 },

                    { x: 100, y: 180, width: 55, height: 12,
                    moving: true, speed: 2.4, direction: 1, minX: 60, maxX: 240 },

                    { x: 160, y: 130, width: 55, height: 12,
                    moving: true, speed: 2.6, direction: -1, minX: 100, maxX: 260 },

                    { x: 125, y: 50, width: 80, height: 15 } // constant final platform
                ];

                cakes = [
                    { x: 45,  y: 365, width: 16, height: 16, collected: false, achievement: 0 },
                    { x: 245, y: 325, width: 16, height: 16, collected: false, achievement: 1 },
                    { x: 85,  y: 285, width: 16, height: 16, collected: false, achievement: 2 },
                    { x: 225, y: 245, width: 16, height: 16, collected: false, achievement: 3 },
                    { x: 115, y: 205, width: 16, height: 16, collected: false, achievement: 4 },
                    { x: 205, y: 165, width: 16, height: 16, collected: false, achievement: 5 },
                    { x: 150, y: 115, width: 16, height: 16, collected: false, achievement: 6 }
                ];
            }

            gameState.totalCakesNeeded = cakes.length;
            gameState.achievements = new Array(cakes.length).fill(false);
            document.getElementById('cakeCount').textContent = 0;
        }

        // startGame will initialize level 1 then game loop
        function startGame() {
            loadLevel(1);
            gameLoop();
        }

        // ---------------- Level End / Transition ----------------
        function triggerLevelEnd() {
            // show heart animation + lock input by setting gameEnded true
            gameState.gameEnded = true;
            heartVisible = true;

            // center camera on sprites (player & goal)
            const centerY = (player.y + goalSprite.y + goalSprite.height / 2) / 2;
            targetCameraOffsetY = (GAME_HEIGHT / 2) - centerY;

            // after animation, either next level or final end screen
            setTimeout(() => {
                if (gameState.level < 3) {
                    gameState.level++;
                    loadLevel(gameState.level);
                } else {
                    // final end
                    endGame();
                }
            }, 2200);
        }

        // keep endGame for showing final end screen (unchanged except used only for final)
        function endGame() {
            gameState.gameEnded = true;
            heartVisible = true;

            const centerY = (player.y + goalSprite.y + goalSprite.height / 2) / 2;
            targetCameraOffsetY = (GAME_HEIGHT / 2) - centerY;

            setTimeout(() => {
                document.getElementById('endScreen').style.display = 'flex';
            }, 2000);
        }

        // ---------------- Update & Draw ----------------
        function update() {
            if (gameState.gameEnded) {
                // Animate heart
                if (heartScale < 1) heartScale += 0.05;
                // Smooth camera scroll to center the sprites
                if (Math.abs(cameraOffsetY - targetCameraOffsetY) > 1) {
                    cameraOffsetY += (targetCameraOffsetY - cameraOffsetY) * 0.1;
                }
                return;
            }

            // Horizontal movement
            player.velocityX = 0;
            if (keys.left) { player.velocityX = -player.speed; player.facing = -1; }
            if (keys.right) { player.velocityX = player.speed; player.facing = 1; }

            // Apply gravity
            player.velocityY += player.gravity;

            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;

            for (let platform of platforms) {
                if (platform.moving) {
                    platform.x += platform.speed * platform.direction;

                    if (platform.x <= platform.minX || platform.x + platform.width >= platform.maxX) {
                        platform.direction *= -1;
                    }
                }
            }

            // Check platform collision
            player.onGround = false;
            for (let platform of platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + platform.height + 10 &&
                    player.velocityY >= 0) {

                    player.y = platform.y - player.height;
                    player.velocityY = 0;
                    player.onGround = true;
                    player.isJumping = false;

                    // Move player along with platform
                    if (platform.moving) {
                        player.x += platform.speed * platform.direction;
                    }
                }
            }

            // Bounds checking
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > GAME_WIDTH) player.x = GAME_WIDTH - player.width;
            if (player.y > GAME_HEIGHT) {
                // fallen off: reset to starting spot for current level
                player.y = GAME_HEIGHT - 100;
                player.x = 50;
                player.velocityY = 0;
            }

            // Check cake collection
            for (let cake of cakes) {
                if (!cake.collected &&
                    player.x + player.width > cake.x &&
                    player.x < cake.x + cake.width &&
                    player.y + player.height > cake.y &&
                    player.y < cake.y + cake.height) {

                    cake.collected = true;
                    gameState.cakesCollected++;
                    // mark achievement for this cake
                    gameState.achievements[cake.achievement] = true;

                    // Update UI
                    document.getElementById('cakeCount').textContent = gameState.cakesCollected;

                    // Show notification (use available achievement text, safe fallback)
                    const text = achievementTexts[cake.achievement] || "üéÇ Cake!";
                    showNotification(text);

                    // NOTE: we do NOT trigger the level end here. Level end triggers on touching sprite3
                }
            }

            // Check goal (sprite3) collision ‚Äî only ends level if all cakes collected
            if (player.x + player.width > goalSprite.x &&
                player.x < goalSprite.x + goalSprite.width &&
                player.y + player.height > goalSprite.y &&
                player.y < goalSprite.y + goalSprite.height) {

                if (gameState.cakesCollected === gameState.totalCakesNeeded) {
                    // Player reached sprite3 after collecting required cakes -> trigger heart/scroll and level transition
                    triggerLevelEnd();
                } else {
                    // optional: you could show a hint notification
                    // showNotification(`Collect ${gameState.totalCakesNeeded - gameState.cakesCollected} more!`);
                }
            }

            // Parallax background
            skyScroll += 0.2;
            if (skyScroll > GAME_WIDTH) skyScroll = 0;
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Save context and apply camera offset
            ctx.save();
            ctx.translate(0, cameraOffsetY);

            // Draw sky2 background with parallax (slower movement)
            if (images.sky2 && images.sky2.complete) {
                ctx.save();
                ctx.translate(0, -cameraOffsetY); // Reset camera for background

                const sky2Width = images.sky2.width;
                const sky2Height = images.sky2.height;
                const parallaxOffset = cameraOffsetY * 0.3;

                for (let y = parallaxOffset - sky2Height; y < GAME_HEIGHT + sky2Height; y += sky2Height) {
                    for (let x = 0; x < GAME_WIDTH; x += sky2Width) {
                        ctx.drawImage(images.sky2, x, y);
                    }
                }

                ctx.restore();
            }

            // Draw platforms
            for (let platform of platforms) {
                if (platform.isGround && images.ground && images.ground.complete) {
                    // Draw ground texture tiled horizontally, stretched to platform.height
                    const groundWidth = images.ground.width;
                    const groundHeight = images.ground.height;

                    for (let x = platform.x; x < platform.x + platform.width; x += groundWidth) {
                        ctx.drawImage(images.ground, x, platform.y, groundWidth, platform.height);
                    }
                } else if (!platform.isGround) {
                    // Draw simple colored platforms
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(platform.x, platform.y, platform.width, 3);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                }
            }

            // Draw cakes
            for (let cake of cakes) {
                if (!cake.collected) {
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(cake.x + cake.width / 2, cake.y + cake.height / 2, cake.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff9900';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(cake.x + cake.width / 2, cake.y + cake.height / 2 - 2, cake.width / 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw player (jumping / idle)
            if (player.isJumping && images.sprite2 && images.sprite2.complete) {
                if (player.facing === -1) {
                    ctx.save();
                    ctx.scale(-1, 1);
                    ctx.drawImage(images.sprite2, -player.x - player.width, player.y, player.width, player.height);
                    ctx.restore();
                } else {
                    ctx.drawImage(images.sprite2, player.x, player.y, player.width, player.height);
                }
            } else if (images.sprite && images.sprite.complete) {
                if (player.facing === -1) {
                    ctx.save();
                    ctx.scale(-1, 1);
                    ctx.drawImage(images.sprite, -player.x - player.width, player.y, player.width, player.height);
                    ctx.restore();
                } else {
                    ctx.drawImage(images.sprite, player.x, player.y, player.width, player.height);
                }
            }

            // Draw goal sprite (sprite3) if all cakes collected and not currently heartVisible
            if (gameState.cakesCollected === gameState.totalCakesNeeded && images.sprite3 && images.sprite3.complete && !heartVisible) {
                ctx.drawImage(images.sprite3, goalSprite.x, goalSprite.y, goalSprite.width, goalSprite.height);
            }

            // Draw heart animation above both sprites when visible
            if (heartVisible) {
                const centerX = (player.x + player.width / 2 + goalSprite.x + goalSprite.width / 2) / 2;
                const centerY = (player.y + goalSprite.y + goalSprite.height / 2) / 2;

                // Draw both sprites (so heart sits above them)
                if (images.sprite && images.sprite.complete) ctx.drawImage(images.sprite, player.x, player.y, player.width, player.height);
                if (images.sprite3 && images.sprite3.complete) ctx.drawImage(images.sprite3, goalSprite.x, goalSprite.y, goalSprite.width, goalSprite.height);

                const heartY = centerY - 50;
                ctx.save();
                ctx.translate(centerX, heartY);
                ctx.scale(heartScale, heartScale);
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ù§Ô∏è', 0, 0);
                ctx.restore();
            }

            ctx.restore();
        }

        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
    </script>
</body>
</html>
